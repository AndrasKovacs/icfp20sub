
{-
-- 2LTT : staging
--   2lTT + extra stuff : different version of monomorphization

-- bunch of notes of 2LTT (not yet anything about layout)
--   layout control (Rust-like mono, levity-polymorphism-like solution)

-- 2LTT
------------------------------------------------------------

   Uᵢ

   A   :   U i  then   ^A : U(i+1)
   <_> :   a : A   then <a> : ^A
   [_] :   a : ^A  then [a] : A

   every eliminator, type former, constructor stays on the same level

-}

-- countable stages
--  level 0       : runtime
--  level (suc _) : compile time

let U0 = U 0 in
let U1 = U 1 in

let id : (A : U0) → A → A
  = λ A x. x in

-- "inline" identity
let id : (A : ^U0) → ^[A] → ^[A]           -- $(A) in TH
  = λ A x. x in

let test : U0 = [id <U0> <U0>] in

-- "inline" composition
let comp : {A B C : ^U0} → (^[B] → ^[C]) → (^[A] → ^[B]) → ^[A] → ^[C]
  = λ f g x. f (g x) in

let test1 : U0 = [comp (id <U0>) (id <U0>) <U0>] in

-- if only types in U1 are of the form ^A
--   we can already control inlining

let comp2 : {A B C : ^U0} → ^([B] → [C]) → ^([A] → [B]) → ^([A] → [C])
  = λ f g. <λ a. [f] ([g] a)> in

let test2 : U0 = [comp2 <λ(x : U0). x> <λ(x : U0).x>] U0 in

-- inductive type in U1

-- Church Nat
let Nat : U0 = (N : U0) → N → (N → N) → N in
let zero : Nat = λ _ z s. z in
let suc : Nat → Nat = λ a _ z s. s (a _ z s) in
let addNat : Nat → Nat → Nat = λ a b N z s. a N (b N z s) s in
let mulNat : Nat → Nat → Nat = λ a b N z s. a N z (λ z. b N z s) in
let n5 : Nat = λ _ z s. s (s (s (s (s z)))) in
let n10 = addNat n5 n5 in

-- Church Nat₁
let Nat₁ : U1 = (N : U1) → N → (N → N) → N in
let zero₁ : Nat₁ = λ _ z s. z in
let suc₁ : Nat₁ → Nat₁ = λ a _ z s. s (a _ z s) in
let add₁ : Nat₁ → Nat₁ → Nat₁ = λ a b N z s. a N (b N z s) s in
let n₁5 : Nat₁ = λ _ z s. s (s (s (s (s z)))) in
let n₁10 = add₁ n₁5 n₁5 in

-- let + stage poly
-- let Nat : ∀ i. U i = (N : U i) → N → (N → N) → N
--
--    if I use (Nat 0) (I keep let-copy around)
--    if I only use (Nat 1) (I can erase this definition)

-- "inline" id
-- id : {A : ^U0} → ^[A] → ^[A]

-- "specialized" id
-- id : {A : ^U0} → ^([A] → [A])  -- (we need some mechanism to share different id-s)


-- lowering: Nat₁ → ^Nat     (in TH: Lift, method lift)

let lowerNat : Nat₁ → ^Nat =
  λ n. n (^Nat) <zero> (λ n. <suc [n]>) in

let test3 : Nat = [lowerNat n₁10] in

  -- n : Nat     --->    <n> : ^Nat
  -- n : Nat₁    --->   [lowerNat n] : Nat

-- "staged" exponentiation (Hello World of staging)
let exp₁ : Nat₁ → Nat → Nat
    = λ a b. a _ (suc zero) (λ n. mulNat n b) in

let exp5 : Nat → Nat = exp₁ n₁5 in

let id : {A : ^U0} → A → A = λ x. x in

let foo : {A : U0} → (A → A) → A → A
  = λ f x. f (f (f x)) in

let bar = λ {A}. foo (id {A}) in

let comp : {A B C : ^U0} → (B → C) → (A → B) → A → C
  = λ f g x. f (g x) in

U0

-- stage inference: coercive subtyping
--   subtyping relation at elaboration time

-- U i < U (i + 1)          coe = ^_
-- A < ^A                   coe = <_>
-- ^A < A                   coe = [_]

-- (A' < A) ∧ (∀ a'. B (coe a') < B' a')
-- ─U i < U (i + 1)         coe = ^_
-- A < ^A                   coe = <_>
-- ^A < A                   coe = [_]

-- (A' < A) ∧ (∀ a'. B (coe a') < B' a')
-- ─────────────────────────────────────
--  ((a : A) → B a) < ((a' : A') → B' a')

--   coe f := λ a'. coe (f (coe a'))

-- Bidir checking, change of direction: check for subtyping
--   (metavars a big complication)

-- Σ types: covariant subtyping rule

-- defining isomorphism of 2LTT: A ~ ^A

-- derivable isomorphisms: ^ preserves all negative type formers

--  ^(A → B) ~ (^A → ^B)
--  ^(A × B) ~ (^A × ^B)
--  ^⊤₀      ~ ⊤₁

-- Typing of Futamura projection with stage polymorphism
-- countable stages + bounded stage polymorphism (∀ i (j ≤ i). ....)
--    (lifting from U i to U j, if I know i ≤ j)

-- STLC interpreter (stage poly)

-- syntax
-- Con : ∀ i. U i
-- Ty  : ∀ i. U i
-- Tm  : ∀ i. Con i → Ty i → U i

-- evalCon : ∀ i (j ≤ i). Con i → U j
-- evalTy  : ∀ i (j ≤ i). Ty  i → U j
-- evalTm  : ∀ i (j ≤ i). {Γ : Con i}{A : Ty i} → Tm Γ A → evalCon Γ → evalTy A

-- abbrev:
--  InterpTy := ∀ i (j ≤ i). {Γ : Con i}{A : Ty i} → Tm Γ A → evalCon Γ → evalTy A

-- three Futamura projections:
-- first: given evalTm and (t : Tm₁ Γ A), return (evalTm 1 0 t)
--     (specialize interpreter for a program)
-- second:
--     given evalTm, return (evalTm 1 0)
-- third:
--     (λ (evalTm : InterpTy). evalTm 1 0)     (stage-polymorphic argument)

-- (every Futamura projection is the identity function when we erase stages)

-- partial evaluation literature: weakly typed

-- PE vs staging:

-- partial evaluation:
--   offline PE: reduction based only on static program annotation (~staging)
--   online  PE: nbe + heuristics
--              (nbe is always a valid PE implementation)

-- do we need online PE if we have staging?
--   yes! because compiler optimization is a form of online PE
--     (opt which is not available in 2LTT, optimization which does not
        preserve definitional 2LTT equality)

{-
- GHC optimization (online PE: heuristics about inlining/unfolding)
   - reduction modulo weak η rule for positive types
   - "case commutation"

     fst (if b then t1 else t2) --> if b then fst t1 else fst t2

     fst (if b then (t1, t2) else t3) --> if b then t1 else t3

     -- if (if b then t1 else t2) then t3 else t4
     --   --> size increase in commutation
     --       (t3 and t4 can be factor out in tail-called function definition)

     --   (the reason for having join points in GHC)
     --      (it's open problem to have join points with dep. types in a nice way)

     way to do compilation:
        - staging (user-controlled)
	- optimization: the basis of opt should be NbE as well (online PE)
	     inlining / unfolding / reduction / weak η-reductions

        - supercompilation: approximate optimization modulo full η rules for
	  positive/inductive types

Staging techniques / related topics (PE literature):

(ways to approximate the possibilities of online PE in a fully typed way)


1. binding-time improvement:

   - For some type find an isomorphic type which can be computed more by staging

   CPS + Church encoding

   Maybe : U0 → U0

   ^(Maybe A) ~
   ^((M : U0) → M → (A → M) → M) ~
    ((M : ^U0) → ^[M] → (^A → ^[M]) → ^[M])

   Maybe' : ^U0 → U1
   Maybe' A := (M : ^U0) → ^[M] → (^[A] → ^[M]) → ^[M]

2. partially static data

   data Nat1 : U1 = Zero | Suc Nat1   -- fully known statically

   data PSNat : U1 = Zero | Suc PSNat | Dyn Nat0  -- "online" PE on PSNat

   add : PSNat → PSNat → PSNat
   add Zero    b = b
   add (Suc a) b = Suc (add a b)
   add (Dyn a) b = Dyn (a + [lower b])

   -- Oleg papers: staged stream fusion

   -- program context may contain a bunch of runtime vars

   λ xs.        run (Map ... (Filter ...) (Drop ... (Dyn xs)))

    -- run function performs fusion/optimization by staging
    -- Map, Filter, Drop : syntactic meta-level things
    --   (Dyn stuff behaves a bit like "neutral" values)

  if we have type A --> generically compute PSA

    (combinatorial explosion for sum types)

  data PS (A : ∀ i. U i) = S (A 1) | D (A 0)
  data PSEither A B = Left (PS A) | Right (PS B) | Dyn (Either (A 0) (B 0))

  -- N-ary sum type
  -- (2^N subsets of constructors could get a constructor in PS version of
  --  the type
  (Aᵢ + Bᵢ + Cᵢ + .... Zᵢ)

     -- we either know which exact constructor the value is or
     --   we know nothing about the constructor

-- Metaprogramming in more generality + tactics (using 2LTT)
--------------------------------------------------------------------------------

-- Coq: tac language, weakly typed, we have no idea whether tac output is
-- well-formed
-- tac programs live in a different world (elaboration optimization, evaluators,
--  nothing can be reused in implementation between tac and core things)

-- performance issue:
--    every tac output has to be re-checked
--    (gluing relies on elaboration ouput being written by humans)
--       - Jason Gross (coq performance github repo)
--       -   (better asymptotics? (more complexity, more constant factors))
--       - Well-typed, first-class metaprogramming
--         (1. I don't have to re-check output)
--         (2. My metaprogram/tactic is visible to glued eval)
--         (If I need huge local scopes: use custom data structure in
--            the metaprogram)
--            (don't have to compute tactics, I can keep them folded)

-- What do we need for this to work? (reproduce tactic language)

-- Induction on ^A  (pattern matching on syntax) (should works)
-- Open problem: Side effects in tactics
--    (backtracking, errors, metacontext manipulation)

-- MTac : almost fully well-typed tactic language for Coq
---  (effects are in a monad)

-- problematic part: monadic traversal on HOAS

--    Π (A : U0) (B : A →ʳ U0)  -->   M U0

     nu  : ∀ A B. (A → M B) → M B
     abs : ∀ A P x. P x → M (∀ (x : A). P x)   -- runtime escape checks

     -- I can magically get a "bound variable" (bv : A)
     -- recurse on (B bv)
     -- magically re-abstract the result, get (M (A → U0)) as result
     --   re-abstraction can fail if the bv escapes

     -- ("representable" function types in ^A)
     -- (PHOAS ?)
     -- (ideas)

-- next week: 2LTT + Memory layout stuff
--------------------------------------------------------------------------------
-}





{-

- 1. monomorphization (Rust-like)     (less powerful, cleaner syntax, aggressive transformation of data by compiler)
                                         every runtime type is canonical
- 2. levity polymorphism (GHC-like)   (more powerful (runtime polymorphism), heavier syntax, more limited data transform)
                                         there are neutral runtime types


-- MonoTT : 2LTT + monomorphization
--------------------------------------------------------------------------------

-- (2 version:
--    1. only uniform types allowed
--    2. lightweight type size calculus)

# Overview

- Types are layouts
- Compile time language is full TT
- Runtime language is simple type theory
 (assume two levels)

Runtime:
  _→_, _×_, _+_, ⊤, ⊥, ADTs, *no universe*

  - every runtime type is canonical in elab output!
  - we could define layouts in a naive parametric way:

    _→_ : closure
    _×_ : flat product
    _+_ : tagged union
    ⊤, ⊥: erased
      (parametric layout computation)
      - non-parametric type former: layout of type former depends on the layout of the parameter types

  - but we don't have to! Since types are fully known, we can easily *compute*
    layouts non-trivially, or let the user specify fine-grained unboxing/packing/padding.

Comptime:
  - Full TT + ^U0 + usual lifting
  - ^U0 is just a name, not a lifting, since there's no U0

    similar to ^U0 in usual 2LTT

  ^_         : Ty₀ Γ → Ty₁ Γ
  (<_>, [_]) : Ty₀ Γ ~ Tm₁ Γ ^U0    -- type iso
  (<_>, [_]) : Tm₀ Γ A ~ Tm₁ Γ ^A   -- term iso
   Bool type₀    --->  <Bool> : U1
   A : ^U0       --->  [A]    : type₀

usual stuff:
  id  : (A : ^U0) → ^[A] → ^[A]
  map : (A B : ^U0) → (^[A] → ^[B]) → ^(List [A]) → ^(List [B])


higher-rank poly works with static functions

  poly : ((A : ^U0) → ^[A] → ^[A]) → ^(Bool × Int)            (C++ template templates)
  poly = λ f. <([f <Bool> <True>], [f <Int> <0>])>

(higher rank functions work, if higher-rank things are statically known)

polymorphic recursion also works, is unfolded at comptime:

  Vec : Nat₁ → ^U0 → ^U0
  Vec 0       A = <⊤>
  Vec (suc n) A = <[A] × [Vec n A]>

  -- (works in Rust/C++ templates)
  map : (n : Nat₁)(A B : ^U0) → (^[A] → ^[B]) → ^(Vec n [A]) → ^(Vec n [B])
  map 0       A B f as = <tt>
  map (suc n) A B f as = <[f <fst [as]>], [map n A B f <snd [as]>]>

-- what happens if I use static identity type?
--   p : Id (^U0) A B ?

--     after staging, we have equality reflection for (Id ^U0 x y)
--        p : Id ^U0 A B   --->  after staging  A is definitionally equal to B

--   (Schröder-Bernstein transport rule)
--


1. Only uniform types
------------------------------------------------------------

- every type is uniform, some are boxed, some are unboxed
- ADTs come in boxed and padded flavor
- padded type recursion must be guarded by boxed type
- relatively easy to represent, better than Rust/GHC   (similar to Sixten)

  (higher kinds:)
    (λ A. <List [A]>) : ^U0 → ^U0     (recover higher kinds)
    (alternative: add a language of runtime kinds)

    elaboration feature : List --> λ A. <List [A]>

    (case expression + recursion in runtime language)

    ( we could have mutation, exceptions, partiality + side effects in the runtime language )
         ( Id ^(Nat₀ → Nat₀) f g )


  padded Bool type where
    true  : Bool
    false : Bool

  boxed Ref (A type) type where
    box : A → Ref A               (0 tag bits)

  padded List (A type) type where
    nil  : List A
    cons : A → Ref (List A) → List A

  boxed List (A type) type where
    nil  : List A
    cons : A → List A → List A

  map : {A B : ^U0} → (^[A] → ^[B]) → ^(List [A]) → ^(List [B])
  map f = letrec go <nil>       = <nil>
                 go <cons a as> = <cons [f <a>] [go <as>]>
          in go

- binding-time-improvement, partially static data:

  Maybe' : ^U0 → U1
  Maybe' A := (M : ^U0) → (^[A] → ^[M]) → ^[M] → ^[M]        (static Church-encoded data)

  data Env (A : ^U0) : U1 where
    nil  : Env A
    snoc : Env A → ^[A] → Env A

(we can still write well-typed staged STLC interpreter)
    cannot write well-typed staged interp for poly/dependent language)

Raw functions: can still capture static variables!

  f : Bool₁ → Nat₁ → ^(Nat →ʳ Nat)
  f True  x = <λʳ y. [lower x] + y>
  f False x = <λʳ y. [lower x] * y>      (after staging "x" capture disappears)

   Γ, x : A ⊢ t : B     Γ ⊢ A type₀    Γ ⊢ B type₀    Γ only has vars in type₁
   ──────────────────────────────────────────────────────────────────────────
                          Γ ⊢ λʳ x. t : A →ʳ B


- obvious layout optimization: padded sum tags unpacked into outer constructor tags
  (type formers are not parametric w.r.t. layout)

   padded Bool = true | false      (1 bit)

  "Ref Bool" has the same layout as

  boxed Bool type where
    true  : Bool
    false : Bool

  padded Maybe A   (1 tag bit + space for A)

  List (Maybe Bool):

  Naive:
    cons     | maybetag | booltag | tail
      1 w        1 w       1 w      1 w        (4 words)       (cons (just true) xs)

  Optimized:
    cons      |  maybetag | booltag  | <unused> |   tail
      32bit       1bit      1bit      30bit        64bit      (2 words)

  List (Maybe (Ref A))
    cons | maybetag | <unused> | payload | tail
     32        1       31          64       64         (3 words)

Limitations:

- data Val = VVar Int | VApp Val Val | VLam (Val → Val)

   data Foo = Con (Int64 × Ref Int64) (Int64 × Ref Int64)
          --> (ptrs and non-pointers grouped)


   VLam metadata : ctr tags + num of ptr, num of non-ptrs in objects

   VLam | ptr (to closure)
    64    64

   unpack closure into constructor:

     runtime obj type | VLam tag | num of ptrs | num of non-ptrs |             <closure data>
         x bits          y bits        ...           ...             some number of ptrs and non-ptrs

   unpack: arrays
     (small generic object: stores known-sized ADT constructors)
     (large generic object: dynamically sized objects fit if we unpack them)

   f : Bool → Bool → Bool → Bool
   f = λ x y z. ...

   let g = f True       --> closure with 1 arg             g False -->
   let g = f True False --> closure with 2 args            g False -->

   GHC: - constructor tags are "magic" parts of runtime object layouts
        - instead: ctor tags should be user unboxed data
	- (have 32 bits of user unboxed space is small generic runtime objects)


- arrays and closures are always boxed, cannot be unpacked
  (workaround for unpacking arrays: generic object containing a boxed array and an unboxed one)

- unpacking is always uniform-sized: (cons (just (box true)) xs) has the same size as (cons nothing xs)

   List (Maybe (Ref Bool))
   cons (just (box true)) xs
   cons nothing xs
   -- sizes are the same!
   -- "non-uniform unpacking"

-- suggestion: restrictions:
   1. only raw function + padded types (hw specification)
   2. only raw function, not closures
        (is there a feature for making defunctionalized closures more convenient?)

   closure construction in Rust/C++:

      λ {....} (....). body     (support for closures with a *single* constructor)
      defunctionalization:      (compiling different lambdas with different captures to a sum type of closures)
                                 (application: switching on all different closures)


-- Non-uniform types
------------------------------------------------------------

runtime types are "abstract size"-indexed

size = exact | bounded | unbounded

   exact < bounded < unbounded
   _⊔_ : size → size → size            (least upper bounds)
                                       (exact ⊔ bounded = bounded)
				       (_ ⊔ unbounded   = unbounded)

  Closures:
  _⇒_   : ty exact → ty exact → ty unbounded
  _×_   : ∀ i j. ty i → ty j → ty (i ⊔ j)
  _+_   : ∀ i j. ty i → ty j → ty (i ⊔ j ⊔ bounded)
  ⊤, ⊥  : ty exact
  Ref   : ∀ i. ty i → ty exact
  Pad   : ty bounded → ty exact
  Array : ty exact → ty unbounded

     (weird: SoA transformation during compilation)
     Array (Ref Int64 × Int64)  --> (2 arrays, one for ptrs, one for non-ptrs)
     (Array is just a primitive object, handled by GC specially so that we don't have to unzip)

  + iso-recursive, size-polymorphic types with parameters
    recursion guarded by Ref

  (alternatively: generic sums, products instead of ×/+, or even SOP (sums-of-products))
    + type fixpoint)
    (easier for generics in static stage)

  type List {i} (A type i) : type (i ⊔ bounded) where
    nil  : List A
    cons : A → Ref (List A) → List A

         -- i ⊔ (i ⊔ bounded) = i ⊔ bounded
         -- exact ⊔ i ⊔ bounded = i ⊔ bounded

  UsualList A := Ref (List A)   -- A can be anything
  RustList A  := Pad (List A)   -- Pad is only well-typed if A is not unbounded

  if Bool is (ty exact) then List Bool is ty bounded

  Pad (List Bool) is exact
  Ref (List Bool) is exact

  List (Maybe (Ref Int))
  List (Pad (Maybe (Ref Int)))


- we still don't have runtime parametricity (Pad, Ref are non-parametric)

- idea: can we have restricted quantifier in the runtime language

   RefΠ : (A : Ty(0,i) Γ) → Ty(0, exact) (Γ, x : Ref A) → Ty (0, exact) Γ

   -- this does not work: Ref is not parametric type former (in layouts)
   --    (we need a more magical "Ref" type which is parametric (genericity overhead))

  -- branch with 0, 1, 2

  type Tree {i} (A : type i) : type (i ⊔ bounded) where
    leaf : A → Tree A
    node : Maybe (Ref (Tree A)) → Maybe (Ref (Tree A)) → Tree A

  -- node only stores the child if we have a just (bitmask-like solution!)

  -- maybe with generic magic: bitmasked arrays in constructors (Data.HashMap in Haskell: has this)


-- Levity polymorphism
--------------------------------------------------------------------------------

(making it up as I go)

- We have full TT both on runtime and compile time + layout control

U1 : U1                -- type-in-type

Rep    : U1
erased : Rep
ref    : Rep
_×_    : Rep → Rep → Rep
Word   : Rep

U0 : Rep → U0 erased   -- type-in-type

    Π0 : {r₁ r₂ : Tm₁ Γ Rep}(A : Ty(0, r₁) Γ) → Ty(0, r₂) (Γ, A) → Ty (0, ref)

    -- layout polymorphism, but no layout dependency (yet)

id : (A : U0 ref) → A → A
id = λ A x. x

-- layout poly id
id : (r : Rep)(A : ^(U0 r)) → ^[A] → ^[A]
id = λ r A x. x


-- vague idea with levity polymorphism:

-- Sigma type with layout dependency, such that layout dependency is statically known, but first projection isn't
--   Sigma type, first projection has rep Word, statically known layout dependency

   (first projection is 64 bit word)

   ΣWord64 :
      (r : Tm (Γ, w : Word64₁)) → Ty (0, r) (Γ, w : Word64₁) → Ty (0, ΣWord64 r)

      _,_ : (t₁ : Tm (0, Word) Γ Word64₀) → ? → Tm (0, ΣWord64) Γ (ΣWord64 B)

       -- runtime term with type Word64₀
       -- I need Word64₁

       -- There is no conversion from Bool₀ to Bool₁
       --                           Word64₀ to Word64₁    (in an arbitrary context)
                            (closed evaluation: Word64₀ cannot be neutral)

   f : Word64₁ → Rep
   f = λ x. ArrayRep ref (x * x)



   (idea: custom RTS objects)
     (static layout dependency --> custom RTS code)
     (user can write new RTS objects (which get GCd, etc.))
      (we still don't need dep. type-passing polymorphism)






























































Extra layout control/optimization features
------------------------------------------------------------

Assumption: function arg & return types have uniform size (simplifies stack manip, GC, calling conventions)

Possible layout computations:
  - 1. normalize to SOP (sum of products): minimize tag sizes
    - layoutOf ((⊤ + ⊤) + ⊤) = layoutOf (⊤ + (⊤ + ⊤))
    - compute number of tag bits
    - flatten nested case expressions

  - 2. don't normalize to SOP: minimize "case" expression sizes

    - constructor tags








  Ref A    : Ty₀ Γ
  *_, box  : A ~ Ref A
  refst    : Ref (A × B) → Ref A   fst *p = *(refst p)
  (refsnd) : Ref (A × B) → Ref B   snd *p = *(refsnd p)   -- we can skip refsnd if we don't want interior ptrs








Since there's no Σ, primitive ADTs or
Recursion must be guarded by Ref (uniformity restriction)

  data List (A : ^U0) : ^U0 where
    nil  : ^[List A]
    cons : ^[A] → ^(Ref [List A]) → ^[List A]

  Bool : ^U0
  Bool = <⊤ + ⊤>

  Maybe : ^U0 → ^U0
  Maybe A = <⊤ + [A]>

  -- layout of ⊤ + ⊤ + ⊤?
               List Bool

-}