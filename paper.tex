
%% build: latexmk -pdf -pvc -xelatex paper.tex

%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[acmsmall]{acmart}\settopmatter{}


%% Journal information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{CONF} % CONF = POPL or ICFP or OOPSLA
\acmArticle{1}
\acmYear{2018}
\acmMonth{1}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Note: Authors migrating a paper from PACMPL format to traditional
%% SIGPLAN proceedings format must update the '\documentclass' and
%% topmatter commands above; see 'acmart-sigplanproc-template.tex'.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption


%% ------------------------------------------------------------

%% \usepackage{fontspec}
%% \fontspec[
%%   Path = fonts/,
%%   BoldFont = *-Bold,
%%   ItalicFont = *-Oblique,
%%   BoldItalicFont = *-BoldOblique]
%%   {DejaVuSansMono}
\setmonofont[Scale=0.8]{DejaVuSansMono}

%% ------------------------------------------------------------


\begin{document}

%% Title information
\title{Elaboration with First-Class Implicit Function Types}


%% Author with single affiliation.
\author{Andr{\'a}s Kov{\'a}cs}
\orcid{0000-0002-6375-9781}
\affiliation{
  \department{Department of Programming Languages and Compilers}
  \institution{E{\"o}tv{\"o}s Lor{\'a}nd University}
  \city{Budapest}
  \country{Hungary}
}
\email{kovacsandras@inf.elte.hu}


\begin{abstract}
Implicit functions are dependently typed functions, such that arguments are
provided (by default) by inference machinery instead of programmers of the
surface language. Implicit functions in Agda are an archetypal example. In the
Haskell language as implemented by the Glasgow Haskell Compiler (GHC),
polymorphic types are another example. Implicit function types are
\emph{first-class} if they are treated as any other type in the surface
language. This is true in Agda and partially true in GHC. Inference and
elaboration in the presence of first-class implicit functions poses a challenge;
in the context of GHC and ML-like languages, this has been dubbed
``impredicative instantiation'' or ``impredicative inference''. We propose a new
framework for elaborating first-class implicit functions, which is applicable
for full dependent type theories and compares favorably to prior solutions in
terms of power, generality and conceptual simplicity. We build atop Norell's
bidirectional elaboration algorithm for Agda, and note that the key issue is
incomplete information about insertions of implicit abstractions and
applications. We make it possible to track and refine information related to
such insertions, by adding a new function type to a core Martin-L\"of type
theory, which supports strict (definitional) currying. This allows us to
represent undetermined domain arities of implicit function types, and we can
decide at any point during elaboration whether implicit abstractions should be
inserted.
\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008</concept_id>
<concept_desc>Software and its engineering~General programming languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003456.10003457.10003521.10003525</concept_id>
<concept_desc>Social and professional topics~History of programming languages</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~General programming languages}
\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code

%% Keywords
%% comma separated list
\keywords{impredicative polymorphism, type theory, elaboration, type inference}
\maketitle


\section{Introduction}

Programmers and users of proof assistants do not like to write out obvious
things. Type inference and elaboration in general serve the purpose of filling
in tedious details, translating terse surface-level languages to explicit core
languages. Modern compilers such as Agda have gotten quite adept at this
task. However, in practice the programmer still has to tell the compiler when
and where to try filling in details on its own.

\textbf{Implicit function types} are a common mechanism for conveying to the
compiler that particular arguments should be inferred by default. In Agda and
Coq, one can use bracketed function domains for this purpose:
\begin{verbatim}
          -- Agda                       (* Coq *)
          id : {A : Set} → A → A        Definition id {A:Type}(x : A) := x.
          id x = x
\end{verbatim}
In GHC, one can use \texttt{forall} to define implicit function
types\footnote{This notation requires language extensions
  \texttt{KindSignatures} and \texttt{RankNTypes}; one could also write the type
  \texttt{a -> a} and GHC would silently insert the quantification.}
\begin{verbatim}
                         id :: forall (a :: *). a -> a
                         id x = x
\end{verbatim}

In all of the above cases, if we apply \texttt{id} to an argument, the implicit
type argument is provided by elaboration. For example, in Agda \texttt{id true}
is elaborated to \texttt{id \{Bool\} true}, and analogously in GHC and Coq. In
all three systems, there is also a way to explicitly specify implicit arguments:
in Agda we may put arguments in brackets as we have seen, in Coq we can prefix a
name with \texttt{@} to make every implicit argument explicit, as in \texttt{@id
  bool true}, and in GHC we can enable the language extension
\texttt{TypeApplications} and write \texttt{id @Bool true}.

Implicit functions are \textbf{first class} if they can be manipulated like any
other type. In Agda, this is the case. For example, we have a list type where
the type of elements is an implicit function, as in \texttt{List (\{A : Set\} →
  A → A)}. That said, Agda's elaboration has limitations when it comes to
handling such types, and in many cases programmers must write out
implicit lambda abstractions.

In Coq, the core language does not have an actual implicit function
type, instead, implicitness is tied to particular \emph{names}, and while we can
write \texttt{List (forall \{A : Set\}, A -> A)}, the brackets here are simply
ignored by Coq. For illustration, Coq accepts the following definition:
\begin{verbatim}
      Definition poly : forall (f : forall {A : Type}, A -> A), bool * nat :=
        fun f => (f bool true, f nat 0).
\end{verbatim}
This is a higher-rank polymorphic function which returns a pair. Note that
\texttt{f} is applied to two arguments, because the implicitness in
\texttt{forall \{A : Type\}, A -> A} is silently dropped.

In GHC Haskell, \texttt{forall} types are somewhere between Agda and Coq. We can certainly write the following, with \texttt{RankNTypes} enabled:
\begin{verbatim}
                    poly :: (forall a. a -> a) -> (Bool, Int)
                    poly f = (f True, f 0)
\end{verbatim}
However, polymorphic types are only supported in function domains and as fields
of algebraic data constructors. We cannot instantiate an arbitrary type
parameter to a \texttt{forall}, as in \texttt{[forall a. a -> a]} for the list
type with polymorphic elements. While this type is technically allowed by the
\texttt{ImpredicativeTypes} language extension, as of GHC 8.8 this extension is
deprecated and is not particularly usable in practice.

There is significant literature on type inference in the presence of first-class
polymorphic types, mainly in relation to GHC and ML-like languages
\cite{TODO}. However, none of the proposed algorithms have landed so far in
production compilers, for reasons of complexity, fragility, interaction with
other language features, or necessity to modify surface or core languages.

\subsection{Contributions}
\begin{itemize}
  \item We propose an elaboration algorithm which translates from a small
    Agda-like surface language to a small Martin-L\"of type theory extended with
    implicit function types, telescopes and \emph{strictly curried} function
    types with telescope domain. The extensions to the target theory are modest
    and are derivable from W-types.
  \item Our algorithm is a conservative extension of Norell's bidirectional
    elaborator for Agda \cite[Chapter~3.6]{norell07thesis}; it accepts strictly more
    programs, and does not require new constructs in the surface language.
  \item Our target language serves as a general platform for elaborating
    implicit functions. The concrete elaborator presented in this paper is a
    relatively simple one, and there is plenty of room to develop more advanced
    elaboration and unification. However, our simple algorithm is already
    comparable or superior to previous solutions for impredicative inference.
  \item We provide a standalone implementation of the elaborator described in
    this paper.
\end{itemize}

\subsection{Note on Terminology}

We prefer to avoid the term ``impredicative inference'' in order to avoid
confusion with impredicativity in type theory, which is an orthogonal notion. In
type theory, impredicativity is a property of a universe, i.e.\ closure of a
universe under arbitrary products. In the type inference literature,
impredicativity means the ability to instantiate type variables and
metavariables to polymorphic types. In particular, we have that
\begin{itemize}
  \item Agda is type-theory-predicative, but implements type-inference-impredicative elaboration.
  \item Coq has type-theory-impredicative $\mathsf{Prop}$ universe, but
    implements type-inference-predicative elaboration.
  \item GHC is type-theory-impredicative with \texttt{RankNTypes} but without
    \texttt{ImpredicativeTypes}, as we have \texttt{(forall a. a -> a) :: *}.

\end{itemize}

\section{Bidirectional Elaboration}

\begin{itemize}
\item Limitations in Agda

\item Insertion of implicits.

\item First-class implicit functions vs Coq.

\item Unique vs non-unique solutions.

\item On the uniqueness of implicit insertion.
\end{itemize}






\begin{acks}
  This work was supported by the European Union, co-financed by the
  European Social Fund (EFOP-3.6.3-VEKOP-16-2017-00002) and COST Action
  EUTypes CA15123.
\end{acks}


%% Bibliography
\bibliography{references}


\end{document}
