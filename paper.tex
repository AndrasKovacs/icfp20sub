
%% build: latexmk -pdf -pvc -xelatex paper.tex

%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[acmsmall,review,anonymous,prologue,dvipsnames]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[acmsmall]{acmart}\settopmatter{}


%% Journal information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{CONF} % CONF = POPL or ICFP or OOPSLA
\acmArticle{1}
\acmYear{2018}
\acmMonth{1}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Note: Authors migrating a paper from PACMPL format to traditional
%% SIGPLAN proceedings format must update the '\documentclass' and
%% topmatter commands above; see 'acmart-sigplanproc-template.tex'.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption


%% ------------------------------------------------------------

%% \usepackage{fontspec}
%% \fontspec[
%%   Path = fonts/,
%%   BoldFont = *-Bold,
%%   ItalicFont = *-Oblique,
%%   BoldItalicFont = *-BoldOblique]
%%   {DejaVuSansMono}
\setmonofont[Colour=blue,Scale=0.8]{DejaVuSansMono}
\usepackage{fancyvrb}
\usepackage{xcolor}
\usepackage{mathpartir}
\usepackage{todonotes}
\presetkeys{todonotes}{inline}{}
\usepackage{scalerel}

%% \newcommand{\blue}[1]{\textcolor{blue}{#1}}
%% \newcommand{\red}[1]{\textcolor{red}{#1}}
%% \newcommand{\green}[1]{\textcolor{ForestGreen}{#1}}
%% \newcommand{\purple}[1]{\textcolor{purple}{#1}}
%% \newcommand{\ASet}{\blue{Set}}
%% \newcommand{\CDefinition}{\blue{Definition}}
%% \newcommand{\CType}{\blue{Type}}
%% \newcommand{\Hforall}{\blue{forall}}
%% \newcommand{\Cforall}{\blue{forall}}
%% \newcommand{\HStar}{\blue{*}}

\newcommand{\slet}{\mathsf{let}}
\renewcommand{\sin}{\mathsf{in}}
\renewcommand{\U}{\mathsf{U}}
\newcommand{\emptycon}{\scaleobj{.75}\bullet}

%% ------------------------------------------------------------


\begin{document}

%% Title information
\title{Elaboration with First-Class Implicit Function Types}


%% Author with single affiliation.
\author{Andr{\'a}s Kov{\'a}cs}
\orcid{0000-0002-6375-9781}
\affiliation{
  \department{Department of Programming Languages and Compilers}
  \institution{E{\"o}tv{\"o}s Lor{\'a}nd University}
  \city{Budapest}
  \country{Hungary}
}
\email{kovacsandras@inf.elte.hu}


\begin{abstract}
Implicit functions are dependently typed functions, such that arguments are
provided (by default) by inference machinery instead of programmers of the
surface language. Implicit functions in Agda are an archetypal example. In the
Haskell language as implemented by the Glasgow Haskell Compiler (GHC),
polymorphic types are another example. Implicit function types are
\emph{first-class} if they are treated as any other type in the surface
language. This is true in Agda and partially true in GHC. Inference and
elaboration in the presence of first-class implicit functions poses a challenge;
in the context of GHC and ML-like languages, this has been dubbed
``impredicative instantiation'' or ``impredicative inference''. We propose a new
framework for elaborating first-class implicit functions, which is applicable
for full dependent type theories and compares favorably to prior solutions in
terms of power, generality and conceptual simplicity. We build atop Norell's
bidirectional elaboration algorithm for Agda, and note that the key issue is
incomplete information about insertions of implicit abstractions and
applications. We make it possible to track and refine information related to
such insertions, by adding a new function type to a core Martin-L\"of type
theory, which supports strict (definitional) currying. This allows us to
represent undetermined domain arities of implicit function types, and we can
decide at any point during elaboration whether implicit abstractions should be
inserted.
\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008</concept_id>
<concept_desc>Software and its engineering~General programming languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003456.10003457.10003521.10003525</concept_id>
<concept_desc>Social and professional topics~History of programming languages</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~General programming languages}
\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code

%% Keywords
%% comma separated list
\keywords{impredicative polymorphism, type theory, elaboration, type inference}
\maketitle


\section{Introduction}

Programmers and users of proof assistants do not like to write out obvious
things. Type inference and elaboration serve the purpose of filling in tedious
details, translating terse surface-level languages to explicit core
languages. Modern compilers such as Agda have gotten quite adept at this
task. However, in practice, programmers still have to tell the compiler when and
where to try filling in details on its own.

\textbf{Implicit function types} are a common mechanism for conveying to the
compiler that particular function arguments should be inferred by default. In
Agda and Coq, one can use bracketed function domains for this purpose:
\begin{Verbatim}[commandchars=\\\{\}]
          -- Agda                     (* Coq *)
          id : \{A : Set\} → A → A      Definition id \{A : Type\}(x : A) := x.
          id x = x
\end{Verbatim}
In GHC, one can use \texttt{forall} to define implicit function
types\footnote{This notation requires language extensions
  \texttt{KindSignatures} and \texttt{RankNTypes}; one could also write the type
  \texttt{a -> a} and GHC would silently insert the quantification.}
\begin{Verbatim}[commandchars=\\\{\}]
                         id :: forall (a :: *). a -> a
                         id x = x
\end{Verbatim}

In all of the above cases, if we apply \texttt{id} to an argument, the implicit
type argument is provided by elaboration. For example, in Agda, \texttt{id true}
is elaborated to \texttt{id \{Bool\} true}, and analogously in GHC and Coq. In all
three systems, there is also a way to explicitly specify implicit arguments: in
Agda we may put arguments in brackets as we have seen, in Coq we can prefix a
name with \texttt{@} to make every implicit argument explicit, as in \texttt{@id
  bool true}, and in GHC we can enable the language extension
\texttt{TypeApplications} and write \texttt{id @Bool True}.

Implicit functions are \textbf{first-class} if they can be manipulated like any
other type. Coq is an example for a system where this is \emph{not} the case.
In Coq, the core language does not have an actual implicit function type,
instead, implicitness is tied to particular \emph{names}, and while we can write
\texttt{List (forall \{A : Type\}, A -> A)}, the brackets here are simply
ignored by Coq and we get a plain function type. For example, Coq accepts the
following definition:
\begin{Verbatim}[commandchars=\\\{\}]
      Definition poly : forall (f : forall \{A : Type\}, A -> A), bool * nat :=
        fun f => (f bool true, f nat 0).
\end{Verbatim}
This is a higher-rank polymorphic function which returns a pair. Note that
\texttt{f} is applied to two arguments, because the implicitness in
\texttt{forall \{A : Type\}, A -> A} is silently dropped.

In GHC Haskell, \texttt{forall} types are more flexible. We can write
the following, with \texttt{RankNTypes} enabled:
\begin{Verbatim}[commandchars=\\\{\}]
                     poly :: (forall a. a -> a) -> (Bool, Int)
                     poly f = (f True, f 0)
\end{Verbatim}
However, polymorphic types are only supported in function domains and as fields
of algebraic data constructors. We cannot instantiate an arbitrary type
parameter to a \texttt{forall}, as in \texttt{[forall a. a -> a]} for a list
type with polymorphic elements. While this type is technically allowed by the
\texttt{ImpredicativeTypes} language extension, as of GHC 8.8 this extension is
deprecated and is not particularly usable in practice.

In Agda, implicit functions are truly a first-class notion, and we may have
\texttt{List (\{A : Set\} → A → A)} without issue. However, Agda's elaboration
still has limitations when it comes to handling implicit functions. Assume that
we have \texttt{[]} for the empty list and \texttt{\_∷\_} for list extension,
and consider the following code:
\begin{Verbatim}[commandchars=\\\{\}]
                     polyList : List (\{A : Set\} → A → A)
                     polyList = (λ x → x) ∷ []
\end{Verbatim}
Agda 2.6.0.1 does not accept this. However, it does accept \texttt{polyList = (λ
  \{A\} x → x) ∷ []}. The issue is the following. Agda first \emph{infers} a
type for \texttt{(λ x → x) ∷ []}, then tries to unify the inferred type with the
given \texttt{List (\{A : Set\} → A → A)} annotation. However, when Agda
elaborates \texttt{λ x → x}, it does not yet know anything about the element
type of the list; it is an undetermined unification variable. Hence, Agda does
not know whether it should insert an extra \texttt{λ\{A\}} or not. If the
element type is later found to be an implicit function, then it should, otherwise it
should not. To solve this conundrum, Agda simply assumes that any unknown type
is \emph{not} an implicit function type, and elects to not insert a lambda. This
assumption is often correct, but sometimes --- as in the current case --- it is not.

There is significant literature on type inference in the presence of first-class
polymorphic types, mainly in relation to GHC and ML-like languages \cite{TODO}.
The above issue in Agda is a specific instance of the challenges described in
the mentioned works. However, none of the proposed algorithms have landed so far
in production compilers, for reasons of complexity, fragility and interaction
with other language features.

The solution presented in this paper is to gradually accummulate information
about implicit insertions, and to have a setup where insertions can be refined
and performed at any time after a particular expression is elaborated. In the
current example, our algorithm wraps \texttt{λ x → x} in an implicit lambda with
unknown arity, and the domain type is later refined to be \texttt{A : Set} when
the inferred type is unified with the annotation.


\subsection{Contributions}
\begin{itemize}
  \item We propose an elaboration algorithm which translates from a small
    Agda-like surface language to a small Martin-L\"of type theory extended with
    implicit function types, telescopes and \emph{strictly curried} function
    types with telescope domain. The extensions to the target theory are modest
    and are derivable from W-types. We use these extensions to accummulate
    information about implicit insertions.
  \item Our algorithm is a conservative extension of Norell's bidirectional
    elaborator for Agda \cite[Chapter~3]{norell07thesis}; it accepts strictly more
    programs, and does not require new constructs in the surface language.
  \item Our target language serves as a general platform for elaborating
    implicit functions. The concrete elaborator presented in this paper is a
    relatively simple one, and there is plenty of room to develop more advanced
    elaboration and unification. However, our simple algorithm is already
    comparable or superior to previous solutions for impredicative inference.
  \item We provide an executable implementation of the elaborator described in
    this paper.
\end{itemize}

\subsubsection{Note on Terminology}

We prefer to avoid the term ``impredicative inference'' in order to avoid
confusion with impredicativity in type theory. The two notions historically
coincided, but has since diverged to the point of being orthogonal. In type
theory, impredicativity is a property of a universe, i.e.\ closure of a universe
under arbitrary products. In the type inference literature, impredicativity
means the ability to instantiate type variables and metavariables to polymorphic
types. In particular, we have that
\begin{itemize}
  \item Agda has type-theory-predicative universes, but implements
    type-inference-impredicative elaboration with first-class implicit function
    types.
  \item Coq has type-theory-impredicative \texttt{Prop} universe (and
    optionally also \texttt{Set}), but implements
    type-inference-predicative elaboration, because of the lack of implicit
    function types.
  \item GHC is type-theory-impredicative with \texttt{RankNTypes} enabled
    and \texttt{ImpredicativeTypes} disabled, as we have
    \texttt{(forall (a :: *). a -> a) :: *}.
\end{itemize}

\section{Basic Bidirectional Elaboration}
\label{sec:basic_bidirectional_elaboration}

First, we present a variant of Norell's bidirectional elaborator
\cite[Chapter~3]{norell07thesis}. Compared to ibid.\ we make some extensions and
simplifications; what we end up with can be viewed as a toy version of the
actual Agda elaborator. In this section, we use it to illustrate the key issues,
and we extend it in Section TODO with additional rules.
\begin{figure}[h]
\begin{alignat*}{4}
  t,\,u,\,v,\,A,\,B,\,C\, :&:=\quad  && x\hspace{8em}              & \text{variable}                 &  \\
                           & |       && (x : A)\to B               & \text{function type}            &  \\
                           & |       && \{x : A\}\to B             & \text{implicit function type}   &  \\
                           & |       && t\,u                       & \text{application}              &  \\
                           & |       && t\,\{u\}                   & \text{implicit application}     &  \\
                           & |       && \lambda\,x.\, t            & \text{lambda abstraction}       &  \\
                           & |       && \lambda\,\{x\}.\,t         & \text{implicit abstraction}     &  \\
                           & |       && \U                         & \text{universe}                 &  \\
                           & |       && \slet\,x : A = t\,\sin\, u & \text{let-definition}           &  \\
                           & |       && \_                         & \text{hole for inferred term}   &
\end{alignat*}
\caption{Syntax of the surface language.}
\label{fig:surface}
\end{figure}

\begin{figure}[h]

\begin{alignat*}{2}
  & \boxed{\Theta\vdash}\hspace{6em}           && \text{\emph{metacontext formation}}\\
  & \boxed{\Theta|\Gamma\vdash}                && \text{\emph{context formation}}\\
  & \boxed{\Theta|\Gamma\vdash t : A}          && \text{\emph{typing}}\\
  & \boxed{\Theta|\Gamma\vdash t \equiv u : A} && \text{\emph{term equality}}
\end{alignat*}

\begin{mathpar}
  \inferrule*[lab=metacon/empty]
             {\\}
             {\emptycon \vdash}

  \inferrule*[lab=metacon/bind]
             {\Theta \vdash \\ \Theta \vdash A : \U}
             {\Theta, \alpha : A \vdash}

  \inferrule*[lab=con/empty]
             {\Theta \vdash}
             {\Theta|\emptycon \vdash}

  \inferrule*[lab=con/bind]
             {\Theta|\Gamma \vdash \\ \Theta|\Gamma \vdash A : \U}
             {\Theta|\Gamma,\,x : A \vdash}

  \inferrule*[lab=con/define]
             {\Theta|\Gamma \vdash \\ \Theta|\Gamma \vdash t : A}
             {\Theta|\Gamma,\,x : A = t \vdash}

  \inferrule*[lab=tm/metavar]
             {\\}
             {\Theta_0,\,\alpha : A,\,\Theta_1|\Gamma \vdash \alpha : A}

  \inferrule*[lab=tm/bound-var]
             {\\}
             {\Theta|\Gamma,\,x : A,\,\Delta \vdash x : A}

  \inferrule*[lab=tm/defined-var]
             {\\}
             {\Theta|\Gamma,\,x : A = t,\,\Delta \vdash x : A}

  \inferrule*[lab=ty/u]
             {\\}
             {\Theta|\Gamma \vdash \U : \U}

  \inferrule*[lab=let]
             {\Theta|\Gamma\vdash t : A \\ \Theta|\Gamma,\,x : A = t \vdash u : B}
             {\Theta|\Gamma\vdash \slet\,x : A = t\,\sin\,u : B[x\mapsto t]}

  \inferrule*[lab=ty/fun]
             {\Theta|\Gamma \vdash A : \U \\ \Theta|\Gamma,\,x : A \vdash B : \U}
             {\Theta|\Gamma \vdash (x : A) \to B : \U}

  \inferrule*[lab=ty/implicit-fun]
             {\Theta|\Gamma \vdash A : \U \\ \Theta|\Gamma,\,x : A \vdash B : \U}
             {\Theta|\Gamma \vdash \{x : A\} \to B : \U}

  \inferrule*[lab=tm/app]
             {\Theta|\Gamma \vdash t : (x : A) \to B \\ \Theta|\Gamma\vdash u : A}
             {\Theta|\Gamma \vdash t\,u : B[x \mapsto u]}

  \inferrule*[lab=tm/implicit-app]
             {\Theta|\Gamma \vdash t : \{x : A\} \to B \\ \Theta|\Gamma\vdash u : A}
             {\Theta|\Gamma \vdash t\,\{u\} : B[x \mapsto u]}

  \inferrule*[lab=tm/lam]
             {\Theta|\Gamma,\,x : A \vdash t : B}
             {\Theta|\Gamma \vdash \lambda\,x.\,t : (x : A) \to B}

  \inferrule*[lab=tm/implicit-lam]
             {\Theta|\Gamma,\,x : A \vdash t : B}
             {\Theta|\Gamma \vdash \lambda\,\{x\}.\,t : \{x : A\} \to B}

  \inferrule*[lab=fun-$\beta$]
             {\Theta|\Gamma,\,x : A \vdash t : B \\\Theta|\Gamma\vdash u : A }
             {\Theta|\Gamma\vdash (\lambda\,x.\,t)\,u \equiv t[x\mapsto u] : B[x\mapsto u]}

  \inferrule*[lab=implicit-fun-$\beta$]
             {\Theta|\Gamma,\,x : A \vdash t : B \\\Theta|\Gamma\vdash u : A }
             {\Theta|\Gamma\vdash (\lambda\,\{x\}.\,t)\,\{u\} \equiv t[x\mapsto u] : B[x\mapsto u]}

  \inferrule*[lab=fun-$\eta$]
             {\Theta|\Gamma\vdash t : (x : A)\to B}
             {\Theta|\Gamma\vdash (\lambda\,x.\,t\,x) \equiv t : (x : A)\to B}

  \inferrule*[lab=implicit-fun-$\eta$]
             {\Theta|\Gamma\vdash t : \{x : A\}\to B}
             {\Theta|\Gamma\vdash (\lambda\,\{x\}.\,t\,\{x\}) \equiv t : \{x : A\}\to B}

  \inferrule*[lab=definition]
             {\\}
             {\Theta|\Gamma,\,x : A = t,\,\Delta \vdash x \equiv t : A}
\end{mathpar}
\caption{Selected rules of the core language.}
\label{fig:plaincore}
\end{figure}

\subsection{Surface syntax}
Figure \ref{fig:surface} shows the the possible constructs in the surface
language. We only have terms, as we have Russell-style universe in the core, and
we can conflate types and terms for convenience. The surface syntax does not
have semantics or any well-formedness relations attached; its sole purpose is to
serve as input to elaboration. Hence, the surface syntax can be also viewed as
a minimal untyped tactic language, which is interpreted by the elaborator.

The syntactic constructs are the almost the same in the surface language as in
the core syntax. The difference is that $\_$ holes only appear in surface
syntax. The $\_$ can be used to request a term to be inferred by elaboration,
the same way as in Agda.  This can be used to give let-definitions without type
annotation, as in $\slet\,x : \_ = \U\,\sin\,x$.

\subsection{Core syntax}

Figure \ref{fig:plaincore} lists selected rules of the core language. We avoid a
fully formal presentation in this paper. Some notes on what is elided:
\begin{itemize}
  \item We use nameful notation and implicit weakening, i.e.\ whenever a term is
    well-formed in some context, it is assumed to be well-formed (as it is) in
    extended contexts. Formally, we would use de Bruijn indices for variables,
    and define variable renaming and parallel substitution by recursion on
    presyntax, e.g.\ as in \cite{schafer2015autosubst}. Also, typing is stable
    under substitution.
  \item
    Definitional equality is understood to be a congruence and an equivalence relation,
    which is respected by substitution and typing.
  \item
    We elide a number of well-formedness assumptions in rules. For instance, whenever
    a context appears in a rule, it is assumed to be well-formed. Likewise, whenever
    we have $\Theta|\Gamma\vdash t : A$, we assume that $\Theta|\Gamma\vdash A : \U$.
\end{itemize}

From now on, we will only consider well-formed core syntax, and only
constructions which respect definitional equality. In other words, we quotient
well-formed syntax by definitional equality.

Alternatively, one could present the syntax as a generalized algebraic theory
\cite{sterling2019algebraic} or a quotient inductive-inductive type
\cite{ttintt}, in which case we would get congruences and quotienting for
definitional equality for free. However, it seems that there are a number of
possible choices for giving an algebraic presentation of metacontexts, and
existing works on algebraic presentations of dependent modal contexts
(e.g.\ \cite{birkedal2018modal}, TODO) do not precisely cover our current use
case. We leave to future work this and the investigation of elaboration from an
algebraic perspective.

\todo{how to refer to mathpartir rules from text?}

\emph{Metacontexts} are used to record metavariables which are created during
elaboration. In our case, metacontexts are simply a context prefix, and we have
variables pointing into it, but we do not support contextual modality e.g.\ as
in \cite{nanevski2008contextual}. The non-meta typing context additionally
supports \emph{defined variables}, which is used in the typing rule for
\emph{let-definitions}, and we have that any defined variable is equal to its
definition. We mainly support this as a convenience feature in the
implementation of our elaborator.

\emph{The universe} $\U$ is Russell-style, and we have the type-in-type rule.
This causes our core syntax to be non-total, and our elaboration algorithm
to be possibly non-terminating. We use type-in-type for simplicity of
presentation, since consistent universe setups are orthogonal to the focus of
this work.

\emph{Function types} only differ from each other in notation: implicit
functions have the same rules as ``explicit'' functions. The primary purpose of
implicit function types is to \emph{guide elaboration}: the elaborator will at
times compute a type and branch on whether it is an implicit function.

\subsubsection{Example programs}

The core syntax is quite expressive as a programming language, thanks to
let-definitions and the type-in-type rule which allows Church-encodings of a
large variety of inductive types. For example, the following term computes a
list of Booleans:

%% \begin{alignat*}{3}
%%   & \slet


%% \end{alignat*}



\begin{acks}
  This work was supported by the European Union, co-financed by the
  European Social Fund (EFOP-3.6.3-VEKOP-16-2017-00002) and COST Action
  EUTypes CA15123.
\end{acks}


%% Bibliography
\bibliography{references}


\end{document}
